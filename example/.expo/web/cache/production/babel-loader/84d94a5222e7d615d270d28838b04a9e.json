{"ast":null,"code":"import _extends from\"@babel/runtime/helpers/extends\";import _defineProperty from\"@babel/runtime/helpers/defineProperty\";import _slicedToArray from\"@babel/runtime/helpers/slicedToArray\";import _regeneratorRuntime from\"@babel/runtime/regenerator\";import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _createClass from\"@babel/runtime/helpers/createClass\";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}import{EventEmitter,Platform,UnavailabilityError}from'expo-modules-core';import{PlaybackMixin,assertStatusValuesInBounds,getNativeSourceAndFullInitialStatusForLoadAsync,getUnloadedStatus}from\"../AV\";import ExponentAV from\"../ExponentAV\";import{throwIfAudioIsDisabled}from\"./AudioAvailability\";export var Sound=function(){function Sound(){var _this=this;_classCallCheck(this,Sound);this._loaded=false;this._loading=false;this._key=null;this._lastStatusUpdate=null;this._lastStatusUpdateTime=null;this._subscriptions=[];this._eventEmitter=new EventEmitter(ExponentAV);this._coalesceStatusUpdatesInMillis=100;this._onPlaybackStatusUpdate=null;this._onMetadataUpdate=null;this._onAudioSampleReceived=null;this._internalStatusUpdateCallback=function(_ref){var key=_ref.key,status=_ref.status;if(_this._key===key){_this._callOnPlaybackStatusUpdateForNewStatus(status);}};this._internalMetadataUpdateCallback=function(_ref2){var key=_ref2.key,metadata=_ref2.metadata;if(_this._key===key){_this._onMetadataUpdate==null?void 0:_this._onMetadataUpdate(metadata);}};this._internalErrorCallback=function(_ref3){var key=_ref3.key,error=_ref3.error;if(_this._key===key){_this._errorCallback(error);}};this._errorCallback=function(error){_this._clearSubscriptions();_this._loaded=false;_this._key=null;_this._callOnPlaybackStatusUpdateForNewStatus(getUnloadedStatus(error));};this.getStatusAsync=function _callee(){var status;return _regeneratorRuntime.async(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:if(!_this._loaded){_context.next=2;break;}return _context.abrupt(\"return\",_this._performOperationAndHandleStatusAsync(function(){return ExponentAV.getStatusForSound(_this._key);}));case 2:status=getUnloadedStatus();_this._callOnPlaybackStatusUpdateForNewStatus(status);return _context.abrupt(\"return\",status);case 5:case\"end\":return _context.stop();}}},null,null,null,Promise);};}_createClass(Sound,[{key:\"_callOnPlaybackStatusUpdateForNewStatus\",value:function _callOnPlaybackStatusUpdateForNewStatus(status){var shouldDismissBasedOnCoalescing=this._lastStatusUpdateTime&&JSON.stringify(status)===this._lastStatusUpdate&&Date.now()-this._lastStatusUpdateTime.getTime()<this._coalesceStatusUpdatesInMillis;if(this._onPlaybackStatusUpdate!=null&&!shouldDismissBasedOnCoalescing){this._onPlaybackStatusUpdate(status);this._lastStatusUpdateTime=new Date();this._lastStatusUpdate=JSON.stringify(status);}}},{key:\"_performOperationAndHandleStatusAsync\",value:function _performOperationAndHandleStatusAsync(operation){var status;return _regeneratorRuntime.async(function _performOperationAndHandleStatusAsync$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:throwIfAudioIsDisabled();if(!this._loaded){_context2.next=9;break;}_context2.next=4;return _regeneratorRuntime.awrap(operation());case 4:status=_context2.sent;this._callOnPlaybackStatusUpdateForNewStatus(status);return _context2.abrupt(\"return\",status);case 9:throw new Error('Cannot complete operation because sound is not loaded.');case 10:case\"end\":return _context2.stop();}}},null,this,null,Promise);}},{key:\"_updateAudioSampleReceivedCallback\",value:function _updateAudioSampleReceivedCallback(){if(global.__EXAV_setOnAudioSampleReceivedCallback==null){if(Platform.OS==='ios'){throw new Error('Failed to set Audio Sample Buffer callback! The JSI function seems to not be installed correctly.');}else{throw new UnavailabilityError('expo-av','setOnAudioSampleReceived');}}if(this._key==null){throw new Error('Cannot set Audio Sample Buffer callback when the Sound instance has not been successfully loaded/initialized!');}if(typeof this._key!=='number'){throw new Error(\"Cannot set Audio Sample Buffer callback when Sound instance key is of type \"+typeof this._key+\"! (expected: number)\");}global.__EXAV_setOnAudioSampleReceivedCallback(this._key,this._onAudioSampleReceived);}},{key:\"_subscribeToNativeEvents\",value:function _subscribeToNativeEvents(){if(this._loaded){this._subscriptions.push(this._eventEmitter.addListener('didUpdatePlaybackStatus',this._internalStatusUpdateCallback),this._eventEmitter.addListener('didUpdateMetadata',this._internalMetadataUpdateCallback));this._subscriptions.push(this._eventEmitter.addListener('ExponentAV.onError',this._internalErrorCallback));}}},{key:\"_clearSubscriptions\",value:function _clearSubscriptions(){this._subscriptions.forEach(function(e){return e.remove();});this._subscriptions=[];}},{key:\"setOnPlaybackStatusUpdate\",value:function setOnPlaybackStatusUpdate(onPlaybackStatusUpdate){this._onPlaybackStatusUpdate=onPlaybackStatusUpdate;this.getStatusAsync();}},{key:\"setOnMetadataUpdate\",value:function setOnMetadataUpdate(onMetadataUpdate){this._onMetadataUpdate=onMetadataUpdate;}},{key:\"setOnAudioSampleReceived\",value:function setOnAudioSampleReceived(callback){this._onAudioSampleReceived=callback;if(this._key!=null){this._updateAudioSampleReceivedCallback();}}},{key:\"loadAsync\",value:function loadAsync(source){var _this2=this;var initialStatus,downloadFirst,_await$getNativeSourc,nativeSource,fullInitialStatus,_args3=arguments;return _regeneratorRuntime.async(function loadAsync$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:initialStatus=_args3.length>1&&_args3[1]!==undefined?_args3[1]:{};downloadFirst=_args3.length>2&&_args3[2]!==undefined?_args3[2]:true;throwIfAudioIsDisabled();if(!this._loading){_context3.next=5;break;}throw new Error('The Sound is already loading.');case 5:if(this._loaded){_context3.next=15;break;}this._loading=true;_context3.next=9;return _regeneratorRuntime.awrap(getNativeSourceAndFullInitialStatusForLoadAsync(source,initialStatus,downloadFirst));case 9:_await$getNativeSourc=_context3.sent;nativeSource=_await$getNativeSourc.nativeSource;fullInitialStatus=_await$getNativeSourc.fullInitialStatus;return _context3.abrupt(\"return\",new Promise(function(resolve,reject){var loadSuccess=function loadSuccess(result){var _result=_slicedToArray(result,2),key=_result[0],status=_result[1];_this2._key=key;_this2._loaded=true;_this2._loading=false;_this2._subscribeToNativeEvents();_this2._callOnPlaybackStatusUpdateForNewStatus(status);resolve(status);};var loadError=function loadError(error){_this2._loading=false;reject(error);};ExponentAV.loadForSound(nativeSource,fullInitialStatus).then(loadSuccess).catch(loadError);}));case 15:throw new Error('The Sound is already loaded.');case 16:case\"end\":return _context3.stop();}}},null,this,null,Promise);}},{key:\"unloadAsync\",value:function unloadAsync(){var key,status;return _regeneratorRuntime.async(function unloadAsync$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:if(!this._loaded){_context4.next=12;break;}this._loaded=false;key=this._key;this._key=null;_context4.next=6;return _regeneratorRuntime.awrap(ExponentAV.unloadForSound(key));case 6:status=_context4.sent;this._callOnPlaybackStatusUpdateForNewStatus(status);this._clearSubscriptions();return _context4.abrupt(\"return\",status);case 12:return _context4.abrupt(\"return\",this.getStatusAsync());case 13:case\"end\":return _context4.stop();}}},null,this,null,Promise);}},{key:\"setStatusAsync\",value:function setStatusAsync(status){var _this3=this;return _regeneratorRuntime.async(function setStatusAsync$(_context5){while(1){switch(_context5.prev=_context5.next){case 0:assertStatusValuesInBounds(status);return _context5.abrupt(\"return\",this._performOperationAndHandleStatusAsync(function(){return ExponentAV.setStatusForSound(_this3._key,status);}));case 2:case\"end\":return _context5.stop();}}},null,this,null,Promise);}},{key:\"replayAsync\",value:function replayAsync(){var _this4=this;var status,_args6=arguments;return _regeneratorRuntime.async(function replayAsync$(_context6){while(1){switch(_context6.prev=_context6.next){case 0:status=_args6.length>0&&_args6[0]!==undefined?_args6[0]:{};if(!(status.positionMillis&&status.positionMillis!==0)){_context6.next=3;break;}throw new Error('Requested position after replay has to be 0.');case 3:return _context6.abrupt(\"return\",this._performOperationAndHandleStatusAsync(function(){return ExponentAV.replaySound(_this4._key,_objectSpread(_objectSpread({},status),{},{positionMillis:0,shouldPlay:true}));}));case 4:case\"end\":return _context6.stop();}}},null,this,null,Promise);}}]);return Sound;}();Sound.create=function _callee2(source){var initialStatus,onPlaybackStatusUpdate,downloadFirst,_args7=arguments;return _regeneratorRuntime.async(function _callee2$(_context7){while(1){switch(_context7.prev=_context7.next){case 0:initialStatus=_args7.length>1&&_args7[1]!==undefined?_args7[1]:{};onPlaybackStatusUpdate=_args7.length>2&&_args7[2]!==undefined?_args7[2]:null;downloadFirst=_args7.length>3&&_args7[3]!==undefined?_args7[3]:true;console.warn(\"Sound.create is deprecated in favor of Sound.createAsync with the same API except for the new method name\");return _context7.abrupt(\"return\",Sound.createAsync(source,initialStatus,onPlaybackStatusUpdate,downloadFirst));case 5:case\"end\":return _context7.stop();}}},null,null,null,Promise);};Sound.createAsync=function _callee3(source){var initialStatus,onPlaybackStatusUpdate,downloadFirst,sound,status,_args8=arguments;return _regeneratorRuntime.async(function _callee3$(_context8){while(1){switch(_context8.prev=_context8.next){case 0:initialStatus=_args8.length>1&&_args8[1]!==undefined?_args8[1]:{};onPlaybackStatusUpdate=_args8.length>2&&_args8[2]!==undefined?_args8[2]:null;downloadFirst=_args8.length>3&&_args8[3]!==undefined?_args8[3]:true;sound=new Sound();sound.setOnPlaybackStatusUpdate(onPlaybackStatusUpdate);_context8.next=7;return _regeneratorRuntime.awrap(sound.loadAsync(source,initialStatus,downloadFirst));case 7:status=_context8.sent;return _context8.abrupt(\"return\",{sound:sound,status:status});case 9:case\"end\":return _context8.stop();}}},null,null,null,Promise);};_extends(Sound.prototype,PlaybackMixin);","map":{"version":3,"sources":["../../src/Audio/Sound.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter, Platform, UnavailabilityError } from 'expo-modules-core';\n\nimport {\n  Playback,\n  PlaybackMixin,\n  AVPlaybackSource,\n  AVMetadata,\n  AVPlaybackStatus,\n  AVPlaybackStatusToSet,\n  assertStatusValuesInBounds,\n  getNativeSourceAndFullInitialStatusForLoadAsync,\n  getUnloadedStatus,\n} from '../AV';\nimport { PitchCorrectionQuality } from '../Audio';\nimport ExponentAV from '../ExponentAV';\nimport { throwIfAudioIsDisabled } from './AudioAvailability';\n\nexport type AudioChannel = {\n  /**\n   * All samples for this specific Audio Channel in PCM Buffer format (-1 to 1).\n   */\n  frames: number[];\n};\n\n/**\n * A single sample from an audio source. The sample contains all frames (PCM Buffer values) for each channel of the audio,\n * so if the audio is _stereo_ (interleaved), there will be two channels, one for left and one for right audio.\n */\nexport type AudioSample = {\n  /**\n   * Data from each Channel in PCM Buffer format.\n   */\n  channels: AudioChannel[];\n  /**\n   * The timestamp of this sample, relative to the Audio Track's timeline in seconds.\n   */\n  timestamp: number;\n};\n\ntype AudioInstance = number | HTMLMediaElement | null;\ntype AudioSampleCallback = ((sample: AudioSample) => void) | null;\n\ndeclare global {\n  interface Global {\n    __EXAV_setOnAudioSampleReceivedCallback:\n      | ((key: number, callback: AudioSampleCallback) => void)\n      | undefined;\n  }\n}\n\nexport class Sound implements Playback {\n  _loaded: boolean = false;\n  _loading: boolean = false;\n  _key: AudioInstance = null;\n  _lastStatusUpdate: string | null = null;\n  _lastStatusUpdateTime: Date | null = null;\n  _subscriptions: { remove: () => void }[] = [];\n  _eventEmitter: EventEmitter = new EventEmitter(ExponentAV);\n  _coalesceStatusUpdatesInMillis: number = 100;\n  _onPlaybackStatusUpdate: ((status: AVPlaybackStatus) => void) | null = null;\n  _onMetadataUpdate: ((metadata: AVMetadata) => void) | null = null;\n  _onAudioSampleReceived: AudioSampleCallback = null;\n\n  /** @deprecated Use `Sound.createAsync()` instead */\n  static create = async (\n    source: AVPlaybackSource,\n    initialStatus: AVPlaybackStatusToSet = {},\n    onPlaybackStatusUpdate: ((status: AVPlaybackStatus) => void) | null = null,\n    downloadFirst: boolean = true\n  ): Promise<{ sound: Sound; status: AVPlaybackStatus }> => {\n    console.warn(\n      `Sound.create is deprecated in favor of Sound.createAsync with the same API except for the new method name`\n    );\n    return Sound.createAsync(source, initialStatus, onPlaybackStatusUpdate, downloadFirst);\n  };\n\n  static createAsync = async (\n    source: AVPlaybackSource,\n    initialStatus: AVPlaybackStatusToSet = {},\n    onPlaybackStatusUpdate: ((status: AVPlaybackStatus) => void) | null = null,\n    downloadFirst: boolean = true\n  ): Promise<{ sound: Sound; status: AVPlaybackStatus }> => {\n    const sound: Sound = new Sound();\n    sound.setOnPlaybackStatusUpdate(onPlaybackStatusUpdate);\n    const status: AVPlaybackStatus = await sound.loadAsync(source, initialStatus, downloadFirst);\n    return { sound, status };\n  };\n\n  // Internal methods\n\n  _callOnPlaybackStatusUpdateForNewStatus(status: AVPlaybackStatus) {\n    const shouldDismissBasedOnCoalescing =\n      this._lastStatusUpdateTime &&\n      JSON.stringify(status) === this._lastStatusUpdate &&\n      Date.now() - this._lastStatusUpdateTime.getTime() < this._coalesceStatusUpdatesInMillis;\n\n    if (this._onPlaybackStatusUpdate != null && !shouldDismissBasedOnCoalescing) {\n      this._onPlaybackStatusUpdate(status);\n      this._lastStatusUpdateTime = new Date();\n      this._lastStatusUpdate = JSON.stringify(status);\n    }\n  }\n\n  async _performOperationAndHandleStatusAsync(\n    operation: () => Promise<AVPlaybackStatus>\n  ): Promise<AVPlaybackStatus> {\n    throwIfAudioIsDisabled();\n    if (this._loaded) {\n      const status = await operation();\n      this._callOnPlaybackStatusUpdateForNewStatus(status);\n      return status;\n    } else {\n      throw new Error('Cannot complete operation because sound is not loaded.');\n    }\n  }\n\n  private _updateAudioSampleReceivedCallback() {\n    if (global.__EXAV_setOnAudioSampleReceivedCallback == null) {\n      if (Platform.OS === 'ios') {\n        throw new Error(\n          'Failed to set Audio Sample Buffer callback! The JSI function seems to not be installed correctly.'\n        );\n      } else {\n        throw new UnavailabilityError('expo-av', 'setOnAudioSampleReceived');\n      }\n    }\n    if (this._key == null) {\n      throw new Error(\n        'Cannot set Audio Sample Buffer callback when the Sound instance has not been successfully loaded/initialized!'\n      );\n    }\n    if (typeof this._key !== 'number') {\n      throw new Error(\n        `Cannot set Audio Sample Buffer callback when Sound instance key is of type ${typeof this\n          ._key}! (expected: number)`\n      );\n    }\n\n    global.__EXAV_setOnAudioSampleReceivedCallback(this._key, this._onAudioSampleReceived);\n  }\n\n  _internalStatusUpdateCallback = ({\n    key,\n    status,\n  }: {\n    key: AudioInstance;\n    status: AVPlaybackStatus;\n  }) => {\n    if (this._key === key) {\n      this._callOnPlaybackStatusUpdateForNewStatus(status);\n    }\n  };\n\n  _internalMetadataUpdateCallback = ({\n    key,\n    metadata,\n  }: {\n    key: AudioInstance;\n    metadata: AVMetadata;\n  }) => {\n    if (this._key === key) {\n      this._onMetadataUpdate?.(metadata);\n    }\n  };\n\n  _internalErrorCallback = ({ key, error }: { key: AudioInstance; error: string }) => {\n    if (this._key === key) {\n      this._errorCallback(error);\n    }\n  };\n\n  // TODO: We can optimize by only using time observer on native if (this._onPlaybackStatusUpdate).\n  _subscribeToNativeEvents() {\n    if (this._loaded) {\n      this._subscriptions.push(\n        this._eventEmitter.addListener(\n          'didUpdatePlaybackStatus',\n          this._internalStatusUpdateCallback\n        ),\n        this._eventEmitter.addListener('didUpdateMetadata', this._internalMetadataUpdateCallback)\n      );\n\n      this._subscriptions.push(\n        this._eventEmitter.addListener('ExponentAV.onError', this._internalErrorCallback)\n      );\n    }\n  }\n\n  _clearSubscriptions() {\n    this._subscriptions.forEach((e) => e.remove());\n    this._subscriptions = [];\n  }\n\n  _errorCallback = (error: string) => {\n    this._clearSubscriptions();\n    this._loaded = false;\n    this._key = null;\n    this._callOnPlaybackStatusUpdateForNewStatus(getUnloadedStatus(error));\n  };\n\n  // ### Unified playback API ### (consistent with Video.js)\n  // All calls automatically call onPlaybackStatusUpdate as a side effect.\n\n  // Get status API\n\n  getStatusAsync = async (): Promise<AVPlaybackStatus> => {\n    if (this._loaded) {\n      return this._performOperationAndHandleStatusAsync(() =>\n        ExponentAV.getStatusForSound(this._key)\n      );\n    }\n    const status: AVPlaybackStatus = getUnloadedStatus();\n    this._callOnPlaybackStatusUpdateForNewStatus(status);\n    return status;\n  };\n\n  setOnPlaybackStatusUpdate(onPlaybackStatusUpdate: ((status: AVPlaybackStatus) => void) | null) {\n    this._onPlaybackStatusUpdate = onPlaybackStatusUpdate;\n    this.getStatusAsync();\n  }\n\n  setOnMetadataUpdate(onMetadataUpdate: (AVMetadata) => void) {\n    this._onMetadataUpdate = onMetadataUpdate;\n  }\n\n  /**\n   * Sets a function to be called during playback, receiving the audio sample as parameter.\n   * @param callback a function taking the {@link AudioSample} as parameter\n   */\n  setOnAudioSampleReceived(callback: AudioSampleCallback) {\n    this._onAudioSampleReceived = callback;\n    if (this._key != null) {\n      this._updateAudioSampleReceivedCallback();\n    }\n  }\n\n  // Loading / unloading API\n\n  async loadAsync(\n    source: AVPlaybackSource,\n    initialStatus: AVPlaybackStatusToSet = {},\n    downloadFirst: boolean = true\n  ): Promise<AVPlaybackStatus> {\n    throwIfAudioIsDisabled();\n    if (this._loading) {\n      throw new Error('The Sound is already loading.');\n    }\n    if (!this._loaded) {\n      this._loading = true;\n\n      const { nativeSource, fullInitialStatus } =\n        await getNativeSourceAndFullInitialStatusForLoadAsync(source, initialStatus, downloadFirst);\n\n      // This is a workaround, since using load with resolve / reject seems to not work.\n      return new Promise<AVPlaybackStatus>((resolve, reject) => {\n        const loadSuccess = (result: [AudioInstance, AVPlaybackStatus]) => {\n          const [key, status] = result;\n          this._key = key;\n          this._loaded = true;\n          this._loading = false;\n          this._subscribeToNativeEvents();\n          this._callOnPlaybackStatusUpdateForNewStatus(status);\n          resolve(status);\n        };\n\n        const loadError = (error: Error) => {\n          this._loading = false;\n          reject(error);\n        };\n\n        ExponentAV.loadForSound(nativeSource, fullInitialStatus).then(loadSuccess).catch(loadError);\n      });\n    } else {\n      throw new Error('The Sound is already loaded.');\n    }\n  }\n\n  async unloadAsync(): Promise<AVPlaybackStatus> {\n    if (this._loaded) {\n      this._loaded = false;\n      const key = this._key;\n      this._key = null;\n      const status = await ExponentAV.unloadForSound(key);\n      this._callOnPlaybackStatusUpdateForNewStatus(status);\n      this._clearSubscriptions();\n      return status;\n    } else {\n      return this.getStatusAsync(); // Automatically calls onPlaybackStatusUpdate.\n    }\n  }\n\n  // Set status API (only available while isLoaded = true)\n\n  async setStatusAsync(status: AVPlaybackStatusToSet): Promise<AVPlaybackStatus> {\n    assertStatusValuesInBounds(status);\n    return this._performOperationAndHandleStatusAsync(() =>\n      ExponentAV.setStatusForSound(this._key, status)\n    );\n  }\n\n  async replayAsync(status: AVPlaybackStatusToSet = {}): Promise<AVPlaybackStatus> {\n    if (status.positionMillis && status.positionMillis !== 0) {\n      throw new Error('Requested position after replay has to be 0.');\n    }\n\n    return this._performOperationAndHandleStatusAsync(() =>\n      ExponentAV.replaySound(this._key, {\n        ...status,\n        positionMillis: 0,\n        shouldPlay: true,\n      })\n    );\n  }\n\n  // Methods of the Playback interface that are set via PlaybackMixin\n  playAsync!: () => Promise<AVPlaybackStatus>;\n  playFromPositionAsync!: (\n    positionMillis: number,\n    tolerances?: { toleranceMillisBefore?: number; toleranceMillisAfter?: number }\n  ) => Promise<AVPlaybackStatus>;\n  pauseAsync!: () => Promise<AVPlaybackStatus>;\n  stopAsync!: () => Promise<AVPlaybackStatus>;\n  setPositionAsync!: (\n    positionMillis: number,\n    tolerances?: { toleranceMillisBefore?: number; toleranceMillisAfter?: number }\n  ) => Promise<AVPlaybackStatus>;\n  setRateAsync!: (\n    rate: number,\n    shouldCorrectPitch: boolean,\n    pitchCorrectionQuality?: PitchCorrectionQuality\n  ) => Promise<AVPlaybackStatus>;\n  setVolumeAsync!: (volume: number) => Promise<AVPlaybackStatus>;\n  setIsMutedAsync!: (isMuted: boolean) => Promise<AVPlaybackStatus>;\n  setIsLoopingAsync!: (isLooping: boolean) => Promise<AVPlaybackStatus>;\n  setProgressUpdateIntervalAsync!: (\n    progressUpdateIntervalMillis: number\n  ) => Promise<AVPlaybackStatus>;\n}\n\nObject.assign(Sound.prototype, PlaybackMixin);\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}